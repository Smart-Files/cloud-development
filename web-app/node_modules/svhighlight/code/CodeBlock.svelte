<!-- 
	Author: bennymi
	Github: https://github.com/bennymi/svhighlight 
	Description: Code highlight component with blur and focus blocks. Inspired and adapted from Skeleton UI (https://www.skeleton.dev/), as well as Torchlight (https://torchlight.dev/).
-->
<script>
	import hljs from 'highlight.js';
	import scrollIntoView from 'scroll-into-view-if-needed';
	import { browser } from '$app/environment';
	import { onMount } from 'svelte';
	import Header from './Header.svelte';
	import CodeLine from './CodeLine.svelte';
	export let language = 'plaintext';
	export let code = '';
	export let highlightLines = '';
	export let focusType = 'blur';
	export let showHeader = true;
	export let headerText = language.toUpperCase();
	export let showLineNumbers = true;
	export let focusBlocks = [];
	export let showFocusButtons = false;
	export let activeFocusBlockStore = null;
	export let background = 'bg-gray-900';
	export let headerClasses = 'bg-gray-800 text-white/80 text-xs font-bold';
	export let focusButtonClasses =
		'flex-grow px-2 py-1 rounded-lg border-2 text-sm font-bold transition-all border-gray-900 text-gray-900 hover:bg-slate-900 hover:shadow-lg hover:shadow-blue-500 hover:text-white';
	export let codeTextClasses = 'text-sm text-white';
	export let lineNumberTextClasses = 'text-white/90';
	export let rounded = 'rounded-lg';
	export let dimensions = 'w-full h-fit';
	export let highlightColor = 'bg-gray-200/10';
	let uniqueID = Math.random().toString(16).slice(2);
	let hiddenCode = '';
	let highlightedLinesList = [];
	let blur = focusType === 'blur';
	let preElement = null;
	let lineElement = null;
	let lines = [];
	let updatedFocusBlocks;
	const scrollToLine = (line) => {
		if (browser) {
			const element = document.getElementById(`svhighlight-${uniqueID}-line-${line}`);
			const parent = document.getElementById(`svhighlight-${uniqueID}-code`);
			scrollIntoView(element, {
				behavior: 'smooth',
				block: 'start',
				boundary: parent
			});
		}
	};
	const handleFocusBlock = (block) => {
		highlightedLinesList = [];
		if (block.scrollLine != void 0 && block.scrollLine >= 0 && block.scrollLine < lines.length)
			scrollToLine(block.scrollLine);
		highlightedLinesList = block.highlightLines;
	};
	const arrayRange = (start, stop) =>
		Array.from({ length: stop - start }, (value, index) => start + index);
	onMount(async () => {
		if (language.toLowerCase() === 'svelte') {
			const { hljsDefineSvelte } = await import('./svelte-highlight');
			hljs.registerLanguage('svelte', hljsDefineSvelte);
			hiddenCode = hljs.highlight(code, { language: 'svelte' }).value.trim();
		} else {
			hiddenCode = hljs.highlight(code, { language }).value.trim();
		}
	});
	$: {
		updatedFocusBlocks = focusBlocks.map((block) => ({
			...block,
			highlightLines: stringToLinesArray(block.lines)
		}));
	}
	$: applyHighlight = (line) => {
		return focusType === 'highlight' && highlightedLinesList.indexOf(line) !== -1;
	};
	const stringToLinesArray = (l) => {
		let linesArray = [];
		const splitHighlights = l.replace(/\s/g, '').split(',');
		splitHighlights.forEach((range) => {
			const splitRange = range.split('-');
			if (splitRange.length === 2) {
				linesArray = [
					...linesArray,
					...arrayRange(parseInt(splitRange[0]), parseInt(splitRange[1]) + 1)
				];
			} else {
				linesArray = [...linesArray, parseInt(splitRange[0])];
			}
		});
		return linesArray.filter((v) => !Number.isNaN(v));
	};
	$: if (highlightLines) {
		highlightedLinesList = [];
		highlightedLinesList = stringToLinesArray(highlightLines);
	}
	$: {
		if (browser) {
			lineElement = document.createElement('div');
			preElement?.childNodes.forEach((node) => {
				if (node.nodeName === 'SPAN' && node.innerHTML.includes('\n')) {
					const splitLines = node.innerHTML.split('\n');
					splitLines.forEach((s, i) => {
						if (s !== '') {
							let newNode = node.cloneNode();
							newNode.innerHTML = s;
							lineElement?.appendChild(newNode);
						}
						if (i !== splitLines.length - 1) {
							lineElement?.appendChild(document.createTextNode('\n'));
						}
					});
				} else {
					let newNode = node.cloneNode();
					newNode.innerHTML = node.innerHTML;
					lineElement.appendChild(newNode);
				}
			});
			lines = lineElement.innerHTML.split('\n');
			lines = lines.map((line) => (line === '' ? ' ' : line));
		}
	}
	$: if (
		activeFocusBlockStore &&
		focusBlocks.length > 0 &&
		$activeFocusBlockStore >= 0 &&
		$activeFocusBlockStore < focusBlocks.length
	) {
		handleFocusBlock(updatedFocusBlocks[$activeFocusBlockStore]);
	}
	$: applyBlur = (line) => {
		return (
			focusType === 'blur' &&
			blur &&
			highlightedLinesList.length > 0 &&
			highlightedLinesList.indexOf(line) === -1
		);
	};
	$: disableBlur = (line) => {
		if (focusType === 'blur' && highlightedLinesList.indexOf(line) === -1) {
			blur = false;
		}
	};
	$: classesHeader = `${headerClasses} ${headerText}`;
	$: classesCodeBlock = `${background} ${codeTextClasses} ${rounded}`;
</script>

<div class="svhiglight-{uniqueID} flex flex-col {dimensions}">
	{#if showFocusButtons && updatedFocusBlocks.length > 0}
		<div class="svhiglight-focus-buttons flex justify-start flex-wrap gap-x-4 gap-y-2">
			{#each updatedFocusBlocks as block, i}
				<button class={focusButtonClasses} on:click={() => handleFocusBlock(block)}>
					{block.text ?? `Focus ${i}`}
				</button>
			{/each}
		</div>
	{/if}

	{#if language && code}
		<div class="svhiglight-{uniqueID}-block flex flex-col overflow-auto mt-2 {classesCodeBlock}">
			<!-- Header -->
			{#if showHeader}
				<Header {classesHeader} {headerText} {code} />
			{/if}

			<!-- This element is hidden. We are only using it to bind it to a variable which has the correct childNodes of the code that should be displayed.
		The other method of creating a new element with document.createElement('div') and setting the innerHTML of it did not work, so this is a hack. -->
			{#if hiddenCode}
				<pre class="hidden"><code bind:this={preElement} class="code-block-code language-{language}"
						>{@html hiddenCode}</code
					></pre>
			{/if}

			<!-- Code display block -->
			{#if lines.length > 0}
				<div id="svhighlight-{uniqueID}-code" class="overflow-auto p-2">
					<!-- Lines -->
					{#each lines as line, i}
						<div
							id="svhighlight-{uniqueID}-line-{i}"
							role="button"
							class="relative transition-all duration-300 ease-in {applyHighlight(i)
								? highlightColor
								: ''} 
							{applyBlur(i) ? 'blur-[0.095rem] opacity-60' : ''}"
							on:mouseenter={() => disableBlur(i)}
							on:mouseleave={() => (blur = true)}
						>
							<CodeLine
								{showLineNumbers}
								{lineNumberTextClasses}
								lineNumber={i}
								{line}
								{language}
							/>
						</div>
					{/each}
				</div>
			{/if}
		</div>
	{/if}
</div>
