import {
  e
} from "./chunk-HVRSG4YR.js";
import {
  es_default
} from "./chunk-RR7E5AVO.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-NRUTNXHJ.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  createEventDispatcher,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  ensure_array_like_dev,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_data_dev,
  space,
  subscribe,
  svg_element,
  text,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-EY2A3J55.js";
import "./chunk-2NWPA7HM.js";
import "./chunk-ZC22LKFR.js";

// node_modules/svhighlight/code/CodeBlock.svelte
import { browser } from "$app/environment";

// node_modules/svhighlight/code/Header.svelte
var file = "node_modules/svhighlight/code/Header.svelte";
function create_else_block(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, class: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M9 18q-.825 0-1.412-.587Q7 16.825 7 16V4q0-.825.588-1.413Q8.175 2 9 2h9q.825 0 1.413.587Q20 3.175 20 4v12q0 .825-.587 1.413Q18.825 18 18 18Zm0-2h9V4H9v12Zm-4 6q-.825 0-1.413-.587Q3 20.825 3 20V7q0-.425.288-.713Q3.575 6 4 6t.713.287Q5 6.575 5 7v13h10q.425 0 .713.288q.287.287.287.712t-.287.712Q15.425 22 15 22ZM9 4v12V4Z");
      add_location(path, file, 35, 5, 1274);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "w-5");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 34, 3, 1196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(34:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, class: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M9 18q-.825 0-1.412-.587Q7 16.825 7 16V4q0-.825.588-1.413Q8.175 2 9 2h9q.825 0 1.413.587Q20 3.175 20 4v12q0 .825-.587 1.413Q18.825 18 18 18Zm-4 4q-.825 0-1.413-.587Q3 20.825 3 20V7q0-.425.288-.713Q3.575 6 4 6t.713.287Q5 6.575 5 7v13h10q.425 0 .713.288q.287.287.287.712t-.287.712Q15.425 22 15 22Z");
      add_location(path, file, 28, 5, 824);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "w-5");
      attr_dev(svg, "viewBox", "0 0 24 24");
      add_location(svg, file, 27, 3, 746);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(27:2) {#if copyState}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let header;
  let span;
  let t0;
  let t1;
  let button;
  let header_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*copyState*/
      ctx2[2]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      header = element("header");
      span = element("span");
      t0 = text(
        /*headerText*/
        ctx[1]
      );
      t1 = space();
      button = element("button");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      span = claim_element(header_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*headerText*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button = claim_element(header_nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      button_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "code-block-language");
      add_location(span, file, 18, 1, 457);
      attr_dev(button, "class", "svhighlight-copy-btn px-2 py-1 rounded-lg transition-all duration-200 text-white/70 hover:text-white/95");
      attr_dev(button, "aria-label", "copy code button");
      add_location(button, file, 21, 1, 538);
      attr_dev(header, "class", header_class_value = "svhighlight-header rounded-t-lg flex justify-between items-center p-2 pl-4 " + /*classesHeader*/
      ctx[0]);
      add_location(header, file, 14, 0, 318);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*handleCopy*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*headerText*/
      2)
        set_data_dev(
          t0,
          /*headerText*/
          ctx2[1]
        );
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty & /*classesHeader*/
      1 && header_class_value !== (header_class_value = "svhighlight-header rounded-t-lg flex justify-between items-center p-2 pl-4 " + /*classesHeader*/
      ctx2[0])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, []);
  let { classesHeader = "" } = $$props;
  let { headerText = "" } = $$props;
  let { code = "" } = $$props;
  let copyState = false;
  const handleCopy = () => {
    navigator.clipboard.writeText(code);
    $$invalidate(2, copyState = true);
    setTimeout(
      () => {
        $$invalidate(2, copyState = false);
      },
      1500
    );
  };
  const writable_props = ["classesHeader", "headerText", "code"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("classesHeader" in $$props2)
      $$invalidate(0, classesHeader = $$props2.classesHeader);
    if ("headerText" in $$props2)
      $$invalidate(1, headerText = $$props2.headerText);
    if ("code" in $$props2)
      $$invalidate(4, code = $$props2.code);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    classesHeader,
    headerText,
    code,
    copyState,
    handleCopy
  });
  $$self.$inject_state = ($$props2) => {
    if ("classesHeader" in $$props2)
      $$invalidate(0, classesHeader = $$props2.classesHeader);
    if ("headerText" in $$props2)
      $$invalidate(1, headerText = $$props2.headerText);
    if ("code" in $$props2)
      $$invalidate(4, code = $$props2.code);
    if ("copyState" in $$props2)
      $$invalidate(2, copyState = $$props2.copyState);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [classesHeader, headerText, copyState, handleCopy, code];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { classesHeader: 0, headerText: 1, code: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment.name
    });
  }
  get classesHeader() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classesHeader(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerText() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerText(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/svhighlight/code/CodeLine.svelte
var file2 = "node_modules/svhighlight/code/CodeLine.svelte";
function create_if_block2(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*lineNumber*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*lineNumber*/
        ctx[2]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "absolute select-none w-10 pr-2 font-mono text-right transition-all duration-300 ease-in " + /*lineNumberTextClasses*/
      ctx[1]);
      add_location(div, file2, 9, 1, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*lineNumber*/
      4)
        set_data_dev(
          t,
          /*lineNumber*/
          ctx2[2]
        );
      if (dirty & /*lineNumberTextClasses*/
      2 && div_class_value !== (div_class_value = "absolute select-none w-10 pr-2 font-mono text-right transition-all duration-300 ease-in " + /*lineNumberTextClasses*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(9:0) {#if showLineNumbers}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let t;
  let div;
  let pre;
  let code;
  let html_tag;
  let code_class_value;
  let div_class_value;
  let if_block = (
    /*showLineNumbers*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      pre = element("pre");
      code = element("code");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      pre = claim_element(div_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code = claim_element(pre_nodes, "CODE", { class: true });
      var code_nodes = children(code);
      html_tag = claim_html_tag(code_nodes, false);
      code_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(code, "class", code_class_value = "language-" + /*language*/
      ctx[4]);
      add_location(code, file2, 17, 29, 511);
      attr_dev(pre, "class", "whitespace-pre");
      add_location(pre, file2, 17, 1, 483);
      attr_dev(div, "class", div_class_value = "transition-all " + /*showLineNumbers*/
      (ctx[0] ? "pl-12" : "pl-2") + " duration-200 ease-in");
      add_location(div, file2, 16, 0, 394);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, code);
      html_tag.m(
        /*line*/
        ctx[3],
        code
      );
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*showLineNumbers*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*line*/
      8)
        html_tag.p(
          /*line*/
          ctx2[3]
        );
      if (dirty & /*language*/
      16 && code_class_value !== (code_class_value = "language-" + /*language*/
      ctx2[4])) {
        attr_dev(code, "class", code_class_value);
      }
      if (dirty & /*showLineNumbers*/
      1 && div_class_value !== (div_class_value = "transition-all " + /*showLineNumbers*/
      (ctx2[0] ? "pl-12" : "pl-2") + " duration-200 ease-in")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeLine", slots, []);
  let { showLineNumbers = false } = $$props;
  let { lineNumberTextClasses = "" } = $$props;
  let { lineNumber } = $$props;
  let { line = "" } = $$props;
  let { language = "" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (lineNumber === void 0 && !("lineNumber" in $$props || $$self.$$.bound[$$self.$$.props["lineNumber"]])) {
      console.warn("<CodeLine> was created without expected prop 'lineNumber'");
    }
  });
  const writable_props = ["showLineNumbers", "lineNumberTextClasses", "lineNumber", "line", "language"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeLine> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("showLineNumbers" in $$props2)
      $$invalidate(0, showLineNumbers = $$props2.showLineNumbers);
    if ("lineNumberTextClasses" in $$props2)
      $$invalidate(1, lineNumberTextClasses = $$props2.lineNumberTextClasses);
    if ("lineNumber" in $$props2)
      $$invalidate(2, lineNumber = $$props2.lineNumber);
    if ("line" in $$props2)
      $$invalidate(3, line = $$props2.line);
    if ("language" in $$props2)
      $$invalidate(4, language = $$props2.language);
  };
  $$self.$capture_state = () => ({
    showLineNumbers,
    lineNumberTextClasses,
    lineNumber,
    line,
    language
  });
  $$self.$inject_state = ($$props2) => {
    if ("showLineNumbers" in $$props2)
      $$invalidate(0, showLineNumbers = $$props2.showLineNumbers);
    if ("lineNumberTextClasses" in $$props2)
      $$invalidate(1, lineNumberTextClasses = $$props2.lineNumberTextClasses);
    if ("lineNumber" in $$props2)
      $$invalidate(2, lineNumber = $$props2.lineNumber);
    if ("line" in $$props2)
      $$invalidate(3, line = $$props2.line);
    if ("language" in $$props2)
      $$invalidate(4, language = $$props2.language);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [showLineNumbers, lineNumberTextClasses, lineNumber, line, language];
}
var CodeLine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      showLineNumbers: 0,
      lineNumberTextClasses: 1,
      lineNumber: 2,
      line: 3,
      language: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeLine",
      options,
      id: create_fragment2.name
    });
  }
  get showLineNumbers() {
    throw new Error("<CodeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLineNumbers(value) {
    throw new Error("<CodeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineNumberTextClasses() {
    throw new Error("<CodeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineNumberTextClasses(value) {
    throw new Error("<CodeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineNumber() {
    throw new Error("<CodeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineNumber(value) {
    throw new Error("<CodeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get line() {
    throw new Error("<CodeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set line(value) {
    throw new Error("<CodeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get language() {
    throw new Error("<CodeLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeLine_default = CodeLine;

// node_modules/svhighlight/code/CodeBlock.svelte
var file3 = "node_modules/svhighlight/code/CodeBlock.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i];
  child_ctx[42] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  child_ctx[42] = i;
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div;
  let each_value_1 = ensure_array_like_dev(
    /*updatedFocusBlocks*/
    ctx[14]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block_1 = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svhiglight-focus-buttons flex justify-start flex-wrap gap-x-4 gap-y-2");
      add_location(div, file3, 149, 2, 5114);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*focusButtonClasses, handleFocusBlock, updatedFocusBlocks*/
      4210816) {
        each_value_1 = ensure_array_like_dev(
          /*updatedFocusBlocks*/
          ctx2[14]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_4.name,
    type: "if",
    source: "(149:1) {#if showFocusButtons && updatedFocusBlocks.length > 0}",
    ctx
  });
  return block_1;
}
function create_each_block_1(ctx) {
  let button;
  let t0_value = (
    /*block*/
    (ctx[43].text ?? `Focus ${/*i*/
    ctx[42]}`) + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[33](
        /*block*/
        ctx[43]
      )
    );
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*focusButtonClasses*/
        ctx[7]
      );
      add_location(button, file3, 151, 4, 5244);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*updatedFocusBlocks*/
      16384 && t0_value !== (t0_value = /*block*/
      (ctx[43].text ?? `Focus ${/*i*/
      ctx[42]}`) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*focusButtonClasses*/
      128) {
        attr_dev(
          button,
          "class",
          /*focusButtonClasses*/
          ctx[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block_1.name,
    type: "each",
    source: "(151:3) {#each updatedFocusBlocks as block, i}",
    ctx
  });
  return block_1;
}
function create_if_block3(ctx) {
  let div;
  let t0;
  let t1;
  let div_class_value;
  let current;
  let if_block0 = (
    /*showHeader*/
    ctx[2] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*hiddenCode*/
    ctx[15] && create_if_block_2(ctx)
  );
  let if_block2 = (
    /*lines*/
    ctx[13].length > 0 && create_if_block_1(ctx)
  );
  const block_1 = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "svhiglight-" + /*uniqueID*/
      ctx[21] + "-block flex flex-col overflow-auto mt-2 " + /*classesCodeBlock*/
      ctx[16]);
      add_location(div, file3, 159, 2, 5423);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*showHeader*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*showHeader*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*hiddenCode*/
        ctx2[15]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*lines*/
        ctx2[13].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*lines*/
          8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesCodeBlock*/
      65536 && div_class_value !== (div_class_value = "svhiglight-" + /*uniqueID*/
      ctx2[21] + "-block flex flex-col overflow-auto mt-2 " + /*classesCodeBlock*/
      ctx2[16])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block3.name,
    type: "if",
    source: "(159:1) {#if language && code}",
    ctx
  });
  return block_1;
}
function create_if_block_3(ctx) {
  let header;
  let current;
  header = new Header_default({
    props: {
      classesHeader: (
        /*classesHeader*/
        ctx[17]
      ),
      headerText: (
        /*headerText*/
        ctx[3]
      ),
      code: (
        /*code*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block_1 = {
    c: function create() {
      create_component(header.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const header_changes = {};
      if (dirty[0] & /*classesHeader*/
      131072)
        header_changes.classesHeader = /*classesHeader*/
        ctx2[17];
      if (dirty[0] & /*headerText*/
      8)
        header_changes.headerText = /*headerText*/
        ctx2[3];
      if (dirty[0] & /*code*/
      2)
        header_changes.code = /*code*/
        ctx2[1];
      header.$set(header_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(header, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_3.name,
    type: "if",
    source: "(162:3) {#if showHeader}",
    ctx
  });
  return block_1;
}
function create_if_block_2(ctx) {
  let pre;
  let code_1;
  let html_tag;
  let code_1_class_value;
  const block_1 = {
    c: function create() {
      pre = element("pre");
      code_1 = element("code");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      html_tag = claim_html_tag(code_1_nodes, false);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(code_1, "class", code_1_class_value = "code-block-code language-" + /*language*/
      ctx[0]);
      add_location(code_1, file3, 168, 24, 5959);
      attr_dev(pre, "class", "hidden");
      add_location(pre, file3, 168, 4, 5939);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, code_1);
      html_tag.m(
        /*hiddenCode*/
        ctx[15],
        code_1
      );
      ctx[34](code_1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*hiddenCode*/
      32768)
        html_tag.p(
          /*hiddenCode*/
          ctx2[15]
        );
      if (dirty[0] & /*language*/
      1 && code_1_class_value !== (code_1_class_value = "code-block-code language-" + /*language*/
      ctx2[0])) {
        attr_dev(code_1, "class", code_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
      ctx[34](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_2.name,
    type: "if",
    source: "(168:3) {#if hiddenCode}",
    ctx
  });
  return block_1;
}
function create_if_block_1(ctx) {
  let div;
  let div_id_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*lines*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block_1 = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", div_id_value = "svhighlight-" + /*uniqueID*/
      ctx[21] + "-code");
      attr_dev(div, "class", "overflow-auto p-2");
      add_location(div, file3, 175, 4, 6148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*uniqueID, applyHighlight, highlightColor, applyBlur, disableBlur, blur, showLineNumbers, lineNumberTextClasses, lines, language*/
      3943697) {
        each_value = ensure_array_like_dev(
          /*lines*/
          ctx2[13]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_1.name,
    type: "if",
    source: "(175:3) {#if lines.length > 0}",
    ctx
  });
  return block_1;
}
function create_each_block(ctx) {
  let div;
  let codeline;
  let t;
  let div_id_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  codeline = new CodeLine_default({
    props: {
      showLineNumbers: (
        /*showLineNumbers*/
        ctx[4]
      ),
      lineNumberTextClasses: (
        /*lineNumberTextClasses*/
        ctx[8]
      ),
      lineNumber: (
        /*i*/
        ctx[42]
      ),
      line: (
        /*line*/
        ctx[40]
      ),
      language: (
        /*language*/
        ctx[0]
      )
    },
    $$inline: true
  });
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[35](
        /*i*/
        ctx[42]
      )
    );
  }
  const block_1 = {
    c: function create() {
      div = element("div");
      create_component(codeline.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, role: true, class: true });
      var div_nodes = children(div);
      claim_component(codeline.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", div_id_value = "svhighlight-" + /*uniqueID*/
      ctx[21] + "-line-" + /*i*/
      ctx[42]);
      attr_dev(div, "role", "button");
      attr_dev(div, "class", div_class_value = "relative transition-all duration-300 ease-in " + /*applyHighlight*/
      (ctx[20](
        /*i*/
        ctx[42]
      ) ? (
        /*highlightColor*/
        ctx[10]
      ) : "") + " " + /*applyBlur*/
      (ctx[19](
        /*i*/
        ctx[42]
      ) ? "blur-[0.095rem] opacity-60" : ""));
      add_location(div, file3, 178, 6, 6269);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(codeline, div, null);
      append_hydration_dev(div, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "mouseenter", mouseenter_handler, false, false, false, false),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const codeline_changes = {};
      if (dirty[0] & /*showLineNumbers*/
      16)
        codeline_changes.showLineNumbers = /*showLineNumbers*/
        ctx[4];
      if (dirty[0] & /*lineNumberTextClasses*/
      256)
        codeline_changes.lineNumberTextClasses = /*lineNumberTextClasses*/
        ctx[8];
      if (dirty[0] & /*lines*/
      8192)
        codeline_changes.line = /*line*/
        ctx[40];
      if (dirty[0] & /*language*/
      1)
        codeline_changes.language = /*language*/
        ctx[0];
      codeline.$set(codeline_changes);
      if (!current || dirty[0] & /*applyHighlight, highlightColor, applyBlur*/
      1573888 && div_class_value !== (div_class_value = "relative transition-all duration-300 ease-in " + /*applyHighlight*/
      (ctx[20](
        /*i*/
        ctx[42]
      ) ? (
        /*highlightColor*/
        ctx[10]
      ) : "") + " " + /*applyBlur*/
      (ctx[19](
        /*i*/
        ctx[42]
      ) ? "blur-[0.095rem] opacity-60" : ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(codeline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(codeline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(codeline);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_each_block.name,
    type: "each",
    source: "(178:5) {#each lines as line, i}",
    ctx
  });
  return block_1;
}
function create_fragment3(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  let if_block0 = (
    /*showFocusButtons*/
    ctx[5] && /*updatedFocusBlocks*/
    ctx[14].length > 0 && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*language*/
    ctx[0] && /*code*/
    ctx[1] && create_if_block3(ctx)
  );
  const block_1 = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "svhiglight-" + /*uniqueID*/
      ctx[21] + " flex flex-col " + /*dimensions*/
      ctx[9]);
      add_location(div, file3, 147, 0, 4992);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*showFocusButtons*/
        ctx2[5] && /*updatedFocusBlocks*/
        ctx2[14].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*language*/
        ctx2[0] && /*code*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*language, code*/
          3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*dimensions*/
      512 && div_class_value !== (div_class_value = "svhiglight-" + /*uniqueID*/
      ctx2[21] + " flex flex-col " + /*dimensions*/
      ctx2[9])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance3($$self, $$props, $$invalidate) {
  let applyHighlight;
  let applyBlur;
  let disableBlur;
  let classesHeader;
  let classesCodeBlock;
  let $activeFocusBlockStore, $$unsubscribe_activeFocusBlockStore = noop, $$subscribe_activeFocusBlockStore = () => ($$unsubscribe_activeFocusBlockStore(), $$unsubscribe_activeFocusBlockStore = subscribe(activeFocusBlockStore, ($$value) => $$invalidate(32, $activeFocusBlockStore = $$value)), activeFocusBlockStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeFocusBlockStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, []);
  let { language = "plaintext" } = $$props;
  let { code = "" } = $$props;
  let { highlightLines = "" } = $$props;
  let { focusType = "blur" } = $$props;
  let { showHeader = true } = $$props;
  let { headerText = language.toUpperCase() } = $$props;
  let { showLineNumbers = true } = $$props;
  let { focusBlocks = [] } = $$props;
  let { showFocusButtons = false } = $$props;
  let { activeFocusBlockStore = null } = $$props;
  validate_store(activeFocusBlockStore, "activeFocusBlockStore");
  $$subscribe_activeFocusBlockStore();
  let { background = "bg-gray-900" } = $$props;
  let { headerClasses = "bg-gray-800 text-white/80 text-xs font-bold" } = $$props;
  let { focusButtonClasses = "flex-grow px-2 py-1 rounded-lg border-2 text-sm font-bold transition-all border-gray-900 text-gray-900 hover:bg-slate-900 hover:shadow-lg hover:shadow-blue-500 hover:text-white" } = $$props;
  let { codeTextClasses = "text-sm text-white" } = $$props;
  let { lineNumberTextClasses = "text-white/90" } = $$props;
  let { rounded = "rounded-lg" } = $$props;
  let { dimensions = "w-full h-fit" } = $$props;
  let { highlightColor = "bg-gray-200/10" } = $$props;
  let uniqueID = Math.random().toString(16).slice(2);
  let hiddenCode = "";
  let highlightedLinesList = [];
  let blur = focusType === "blur";
  let preElement = null;
  let lineElement = null;
  let lines = [];
  let updatedFocusBlocks;
  const scrollToLine = (line) => {
    if (browser) {
      const element2 = document.getElementById(`svhighlight-${uniqueID}-line-${line}`);
      const parent = document.getElementById(`svhighlight-${uniqueID}-code`);
      e(element2, {
        behavior: "smooth",
        block: "start",
        boundary: parent
      });
    }
  };
  const handleFocusBlock = (block) => {
    $$invalidate(30, highlightedLinesList = []);
    if (block.scrollLine != void 0 && block.scrollLine >= 0 && block.scrollLine < lines.length)
      scrollToLine(block.scrollLine);
    $$invalidate(30, highlightedLinesList = block.highlightLines);
  };
  const arrayRange = (start, stop) => Array.from({ length: stop - start }, (value, index) => start + index);
  onMount(async () => {
    if (language.toLowerCase() === "svelte") {
      const { hljsDefineSvelte } = await import("./svelte-highlight-G7APVIPP.js");
      es_default.registerLanguage("svelte", hljsDefineSvelte);
      $$invalidate(15, hiddenCode = es_default.highlight(code, { language: "svelte" }).value.trim());
    } else {
      $$invalidate(15, hiddenCode = es_default.highlight(code, { language }).value.trim());
    }
  });
  const stringToLinesArray = (l) => {
    let linesArray = [];
    const splitHighlights = l.replace(/\s/g, "").split(",");
    splitHighlights.forEach((range) => {
      const splitRange = range.split("-");
      if (splitRange.length === 2) {
        linesArray = [
          ...linesArray,
          ...arrayRange(parseInt(splitRange[0]), parseInt(splitRange[1]) + 1)
        ];
      } else {
        linesArray = [...linesArray, parseInt(splitRange[0])];
      }
    });
    return linesArray.filter((v) => !Number.isNaN(v));
  };
  const writable_props = [
    "language",
    "code",
    "highlightLines",
    "focusType",
    "showHeader",
    "headerText",
    "showLineNumbers",
    "focusBlocks",
    "showFocusButtons",
    "activeFocusBlockStore",
    "background",
    "headerClasses",
    "focusButtonClasses",
    "codeTextClasses",
    "lineNumberTextClasses",
    "rounded",
    "dimensions",
    "highlightColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CodeBlock> was created with unknown prop '${key}'`);
  });
  const click_handler = (block) => handleFocusBlock(block);
  function code_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      preElement = $$value;
      $$invalidate(12, preElement);
    });
  }
  const mouseenter_handler = (i) => disableBlur(i);
  const mouseleave_handler = () => $$invalidate(11, blur = true);
  $$self.$$set = ($$props2) => {
    if ("language" in $$props2)
      $$invalidate(0, language = $$props2.language);
    if ("code" in $$props2)
      $$invalidate(1, code = $$props2.code);
    if ("highlightLines" in $$props2)
      $$invalidate(23, highlightLines = $$props2.highlightLines);
    if ("focusType" in $$props2)
      $$invalidate(24, focusType = $$props2.focusType);
    if ("showHeader" in $$props2)
      $$invalidate(2, showHeader = $$props2.showHeader);
    if ("headerText" in $$props2)
      $$invalidate(3, headerText = $$props2.headerText);
    if ("showLineNumbers" in $$props2)
      $$invalidate(4, showLineNumbers = $$props2.showLineNumbers);
    if ("focusBlocks" in $$props2)
      $$invalidate(25, focusBlocks = $$props2.focusBlocks);
    if ("showFocusButtons" in $$props2)
      $$invalidate(5, showFocusButtons = $$props2.showFocusButtons);
    if ("activeFocusBlockStore" in $$props2)
      $$subscribe_activeFocusBlockStore($$invalidate(6, activeFocusBlockStore = $$props2.activeFocusBlockStore));
    if ("background" in $$props2)
      $$invalidate(26, background = $$props2.background);
    if ("headerClasses" in $$props2)
      $$invalidate(27, headerClasses = $$props2.headerClasses);
    if ("focusButtonClasses" in $$props2)
      $$invalidate(7, focusButtonClasses = $$props2.focusButtonClasses);
    if ("codeTextClasses" in $$props2)
      $$invalidate(28, codeTextClasses = $$props2.codeTextClasses);
    if ("lineNumberTextClasses" in $$props2)
      $$invalidate(8, lineNumberTextClasses = $$props2.lineNumberTextClasses);
    if ("rounded" in $$props2)
      $$invalidate(29, rounded = $$props2.rounded);
    if ("dimensions" in $$props2)
      $$invalidate(9, dimensions = $$props2.dimensions);
    if ("highlightColor" in $$props2)
      $$invalidate(10, highlightColor = $$props2.highlightColor);
  };
  $$self.$capture_state = () => ({
    hljs: es_default,
    scrollIntoView: e,
    browser,
    onMount,
    Header: Header_default,
    CodeLine: CodeLine_default,
    language,
    code,
    highlightLines,
    focusType,
    showHeader,
    headerText,
    showLineNumbers,
    focusBlocks,
    showFocusButtons,
    activeFocusBlockStore,
    background,
    headerClasses,
    focusButtonClasses,
    codeTextClasses,
    lineNumberTextClasses,
    rounded,
    dimensions,
    highlightColor,
    uniqueID,
    hiddenCode,
    highlightedLinesList,
    blur,
    preElement,
    lineElement,
    lines,
    updatedFocusBlocks,
    scrollToLine,
    handleFocusBlock,
    arrayRange,
    stringToLinesArray,
    classesCodeBlock,
    classesHeader,
    disableBlur,
    applyBlur,
    applyHighlight,
    $activeFocusBlockStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("language" in $$props2)
      $$invalidate(0, language = $$props2.language);
    if ("code" in $$props2)
      $$invalidate(1, code = $$props2.code);
    if ("highlightLines" in $$props2)
      $$invalidate(23, highlightLines = $$props2.highlightLines);
    if ("focusType" in $$props2)
      $$invalidate(24, focusType = $$props2.focusType);
    if ("showHeader" in $$props2)
      $$invalidate(2, showHeader = $$props2.showHeader);
    if ("headerText" in $$props2)
      $$invalidate(3, headerText = $$props2.headerText);
    if ("showLineNumbers" in $$props2)
      $$invalidate(4, showLineNumbers = $$props2.showLineNumbers);
    if ("focusBlocks" in $$props2)
      $$invalidate(25, focusBlocks = $$props2.focusBlocks);
    if ("showFocusButtons" in $$props2)
      $$invalidate(5, showFocusButtons = $$props2.showFocusButtons);
    if ("activeFocusBlockStore" in $$props2)
      $$subscribe_activeFocusBlockStore($$invalidate(6, activeFocusBlockStore = $$props2.activeFocusBlockStore));
    if ("background" in $$props2)
      $$invalidate(26, background = $$props2.background);
    if ("headerClasses" in $$props2)
      $$invalidate(27, headerClasses = $$props2.headerClasses);
    if ("focusButtonClasses" in $$props2)
      $$invalidate(7, focusButtonClasses = $$props2.focusButtonClasses);
    if ("codeTextClasses" in $$props2)
      $$invalidate(28, codeTextClasses = $$props2.codeTextClasses);
    if ("lineNumberTextClasses" in $$props2)
      $$invalidate(8, lineNumberTextClasses = $$props2.lineNumberTextClasses);
    if ("rounded" in $$props2)
      $$invalidate(29, rounded = $$props2.rounded);
    if ("dimensions" in $$props2)
      $$invalidate(9, dimensions = $$props2.dimensions);
    if ("highlightColor" in $$props2)
      $$invalidate(10, highlightColor = $$props2.highlightColor);
    if ("uniqueID" in $$props2)
      $$invalidate(21, uniqueID = $$props2.uniqueID);
    if ("hiddenCode" in $$props2)
      $$invalidate(15, hiddenCode = $$props2.hiddenCode);
    if ("highlightedLinesList" in $$props2)
      $$invalidate(30, highlightedLinesList = $$props2.highlightedLinesList);
    if ("blur" in $$props2)
      $$invalidate(11, blur = $$props2.blur);
    if ("preElement" in $$props2)
      $$invalidate(12, preElement = $$props2.preElement);
    if ("lineElement" in $$props2)
      $$invalidate(31, lineElement = $$props2.lineElement);
    if ("lines" in $$props2)
      $$invalidate(13, lines = $$props2.lines);
    if ("updatedFocusBlocks" in $$props2)
      $$invalidate(14, updatedFocusBlocks = $$props2.updatedFocusBlocks);
    if ("classesCodeBlock" in $$props2)
      $$invalidate(16, classesCodeBlock = $$props2.classesCodeBlock);
    if ("classesHeader" in $$props2)
      $$invalidate(17, classesHeader = $$props2.classesHeader);
    if ("disableBlur" in $$props2)
      $$invalidate(18, disableBlur = $$props2.disableBlur);
    if ("applyBlur" in $$props2)
      $$invalidate(19, applyBlur = $$props2.applyBlur);
    if ("applyHighlight" in $$props2)
      $$invalidate(20, applyHighlight = $$props2.applyHighlight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*focusBlocks*/
    33554432) {
      $: {
        $$invalidate(14, updatedFocusBlocks = focusBlocks.map((block) => ({
          ...block,
          highlightLines: stringToLinesArray(block.lines)
        })));
      }
    }
    if ($$self.$$.dirty[0] & /*highlightLines*/
    8388608) {
      $:
        if (highlightLines) {
          $$invalidate(30, highlightedLinesList = []);
          $$invalidate(30, highlightedLinesList = stringToLinesArray(highlightLines));
        }
    }
    if ($$self.$$.dirty[0] & /*focusType, highlightedLinesList*/
    1090519040) {
      $:
        $$invalidate(20, applyHighlight = (line) => {
          return focusType === "highlight" && highlightedLinesList.indexOf(line) !== -1;
        });
    }
    if ($$self.$$.dirty[0] & /*preElement, lines*/
    12288 | $$self.$$.dirty[1] & /*lineElement*/
    1) {
      $: {
        if (browser) {
          $$invalidate(31, lineElement = document.createElement("div"));
          preElement == null ? void 0 : preElement.childNodes.forEach((node) => {
            if (node.nodeName === "SPAN" && node.innerHTML.includes("\n")) {
              const splitLines = node.innerHTML.split("\n");
              splitLines.forEach((s, i) => {
                if (s !== "") {
                  let newNode = node.cloneNode();
                  newNode.innerHTML = s;
                  lineElement == null ? void 0 : lineElement.appendChild(newNode);
                }
                if (i !== splitLines.length - 1) {
                  lineElement == null ? void 0 : lineElement.appendChild(document.createTextNode("\n"));
                }
              });
            } else {
              let newNode = node.cloneNode();
              newNode.innerHTML = node.innerHTML;
              lineElement.appendChild(newNode);
            }
          });
          $$invalidate(13, lines = lineElement.innerHTML.split("\n"));
          $$invalidate(13, lines = lines.map((line) => line === "" ? " " : line));
        }
      }
    }
    if ($$self.$$.dirty[0] & /*activeFocusBlockStore, focusBlocks, updatedFocusBlocks*/
    33570880 | $$self.$$.dirty[1] & /*$activeFocusBlockStore*/
    2) {
      $:
        if (activeFocusBlockStore && focusBlocks.length > 0 && $activeFocusBlockStore >= 0 && $activeFocusBlockStore < focusBlocks.length) {
          handleFocusBlock(updatedFocusBlocks[$activeFocusBlockStore]);
        }
    }
    if ($$self.$$.dirty[0] & /*focusType, highlightedLinesList*/
    1090519040) {
      $:
        $$invalidate(18, disableBlur = (line) => {
          if (focusType === "blur" && highlightedLinesList.indexOf(line) === -1) {
            $$invalidate(11, blur = false);
          }
        });
    }
    if ($$self.$$.dirty[0] & /*focusType, blur, highlightedLinesList*/
    1090521088) {
      $:
        $$invalidate(19, applyBlur = (line) => {
          return focusType === "blur" && blur && highlightedLinesList.length > 0 && highlightedLinesList.indexOf(line) === -1;
        });
    }
    if ($$self.$$.dirty[0] & /*headerClasses, headerText*/
    134217736) {
      $:
        $$invalidate(17, classesHeader = `${headerClasses} ${headerText}`);
    }
    if ($$self.$$.dirty[0] & /*background, codeTextClasses, rounded*/
    872415232) {
      $:
        $$invalidate(16, classesCodeBlock = `${background} ${codeTextClasses} ${rounded}`);
    }
  };
  return [
    language,
    code,
    showHeader,
    headerText,
    showLineNumbers,
    showFocusButtons,
    activeFocusBlockStore,
    focusButtonClasses,
    lineNumberTextClasses,
    dimensions,
    highlightColor,
    blur,
    preElement,
    lines,
    updatedFocusBlocks,
    hiddenCode,
    classesCodeBlock,
    classesHeader,
    disableBlur,
    applyBlur,
    applyHighlight,
    uniqueID,
    handleFocusBlock,
    highlightLines,
    focusType,
    focusBlocks,
    background,
    headerClasses,
    codeTextClasses,
    rounded,
    highlightedLinesList,
    lineElement,
    $activeFocusBlockStore,
    click_handler,
    code_1_binding,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        language: 0,
        code: 1,
        highlightLines: 23,
        focusType: 24,
        showHeader: 2,
        headerText: 3,
        showLineNumbers: 4,
        focusBlocks: 25,
        showFocusButtons: 5,
        activeFocusBlockStore: 6,
        background: 26,
        headerClasses: 27,
        focusButtonClasses: 7,
        codeTextClasses: 28,
        lineNumberTextClasses: 8,
        rounded: 29,
        dimensions: 9,
        highlightColor: 10
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment3.name
    });
  }
  get language() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightLines() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightLines(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusType() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusType(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showHeader() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showHeader(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerText() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerText(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showLineNumbers() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showLineNumbers(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusBlocks() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusBlocks(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFocusButtons() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFocusButtons(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeFocusBlockStore() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeFocusBlockStore(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headerClasses() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerClasses(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusButtonClasses() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusButtonClasses(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get codeTextClasses() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set codeTextClasses(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineNumberTextClasses() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineNumberTextClasses(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dimensions() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dimensions(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightColor() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightColor(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;
export {
  CodeBlock_default as CodeBlock
};
//# sourceMappingURL=svhighlight.js.map
